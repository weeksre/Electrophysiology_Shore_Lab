function m_sort(superblock,tank_path,save_dir,varargin)
% Input:
% SUPERBLOCK (1x1 cell), generated by the BUILD_SB or LOAD_SB functions
% TANK_PATH (cell array or char), providing the full tank path of TDT tanks
% SAVE_DIR (char), directory where the program will store sorted and
% miscellanous data.
%
% This function aligns waveforms (Quiroga method; ALIGN_SNIP) from each
% channel of the superblock structure, plots samples of PCA75 features in
% 3D and allows users to assign clusters to different units. Once sortcodes
% from each channel are gathered, the program loads single-tank or multi-
% tank SSTs (SUPERSPIKETRAIN or SUPERSPIKETRAIN_MULTI) of each unit and
% saved as .mat files. PCA features, aligned waveforms, or sortcodes are
% generated during check-point processing (which allows user to resume
% sorting progress), but are discarded after SSTs are saved.
%
% List of other required and useful(*) function files:
% align_snip.m
% pca75.m
% superspiketrain.m
% superspiketrain_multi.m
% mergeDS.m
% build_sb.m (*)
% load_sb.m (*)
% get_sorted_sst.m (*)
%
% v-1.0 (dated 5-28-2016)
%
% By Calvin Wu
% KHRI-SES-Lab
%
%
% v-1.1 notes (6-2-2016):
% Added capability to do automatic clustering with 1) EM_GMM or 2) K-mean.
% Incorporated into the sorting platform.
%
% Additional function files required:
% em_gmm.m
% sorter_kmeans.m
%
% Also fixed mouse button press issue and added zooming.
%
%
% v-1.2 notes (6-3-2016):
% Fixed bugs. Added an option to go back n number of channels, despite
% existing checkpoint. Activate this option by putting 1,2... (go back
% 1,2...) in varargin. Warning: the existing checkpoint will be rewritten
% with new checkpoint.
%
% v-1.3 notes (6-17-2016):
% Fixed bugs. Added cluster re-centering to 'r'. Now plotting waveform and
% ISI for post-sort selection.
%
% v-1.4 notes (7-6-2016):
% Fixed bugs that occurred when a channel has too few spikes causing PCA to
% return error.
%
% v-1.5 notes (1-20-2017):
% Added option to skip sorting and return multichannel only
%
% v-1.6 notes (9-25-2018):
% Final saved data duplicated as json (python readable).


[~,ttss1]=fileparts(tank_path);
[~,ttss2]=fileparts(save_dir);
titlestring=[ttss1,'--',ttss2];


[tank,blocks] = sb_structure(superblock{1});

% alignment amount is default at 5, but could try 10.
shift=5;

max_ch = max(superblock{1}.chan);

% checkpoint processing at two levels:
% 1) before or after steps that require user input (user_finished)
% 2) per channel
checkpoint_path = fullfile(save_dir, 'checkpoint.mat');

ch_start_sort=1;
ch_start_sst=1;
sort_code={};
user_finished=false;
skip_sorting=false;
if ~isempty(varargin)
    if isnumeric(varargin{1})
        nstep=varargin{1};
        skip_sorting=false;
    else
        skip_sorting=true;
    end
else
    nstep=0;
end

if ~skip_sorting
if exist(checkpoint_path, 'file')
    ch_start_load=load(checkpoint_path);
    if nstep>ch_start_load.ch_sort;
        nstep=ch_start_load.ch_sort;
    end
    sort_code=ch_start_load.sort_code;
    ch_start_sort=ch_start_load.ch_sort+1-nstep;
    ch_start_sst=ch_start_load.ch_sst;
    user_finished=ch_start_load.user_finished;
end

ch_sst=0;
ch_sort=0;
if ~user_finished
    for ch=ch_start_sort:max_ch
        tbl = superblock{1}(superblock{1}.chan==ch,:);
        if height(tbl)>10
            clc
            fprintf('Plotting channel %d... (%d)\n',ch,height(tbl))
            tbl_aligned = align_snip(tbl.waves, shift, false);
            [fspace_all explained] = pca75(tbl_aligned);
            instruction_display();
            close all;
            sort_code{ch} = user_sort(fspace_all,ch,titlestring,explained);
            if sum(sort_code{ch})>1
                tbl.sortc=sort_code{ch};
                display_unit(tbl);
                L=display_isi(tbl);
                index_keep = sb_select(L);
                new_sortcode = find(index_keep);
                sort_code_copy = zeros(size(sort_code{ch}));
                for i=1:length(new_sortcode)
                    sort_code_copy(sort_code{ch}==new_sortcode(i))=i;
                end
                sort_code{ch}=sort_code_copy;
                tbl.sortc=sort_code_copy;
            end
        else
            sort_code{ch}=NaN;
        end
        ch_sort=ch;
        save(checkpoint_path,'ch_sort','ch_sst','sort_code','user_finished');
    end
    user_finished=true;
    ch_start_sst=1;
end
end

disp('Processing sst...')
if ~skip_sorting
for ch=ch_start_sst:max_ch
    
    tbl = superblock{1}(superblock{1}.chan==ch,:);
    sst = import_sst(tank,blocks,tank_path,ch);
    
    
    if ~isnan(sort_code{ch})
        tbl.sortc = sort_code{ch};
        sst_sorted = export_sst(tbl,sst);
        var_name = ['channel_' num2str(ch)];
        sst_sorted(1)=[];
        
        if ~isempty(sst_sorted)
            save(fullfile(save_dir,var_name),'sst_sorted')

            J = sstcell2py(sst_sorted);
            var_name = ['channel_' num2str(ch) '.json'];
            fid=fopen(fullfile(save_dir,var_name),'w');
            fprintf(fid,J);
            fclose(fid);

            disp(['Channel ' num2str(ch) ' sorted.'])
        end
    end
    ch_sst=ch;
    save(checkpoint_path,'ch_sort','ch_sst','sort_code','user_finished');
end

else
    for ch=ch_start_sst:max_ch
        tbl = superblock{1}(superblock{1}.chan==ch,:);
        sst = import_sst(tank,blocks,tank_path,ch);
        sst_sorted=cell(1,1);
        sst_sorted{1}=sst;
        var_name = ['channel_' num2str(ch)];
        save(fullfile(save_dir,var_name),'sst_sorted') 

        J = sstcell2py(sst_sorted);
        var_name = ['channel_' num2str(ch) '.json'];
        fid=fopen(fullfile(save_dir,var_name),'w');
        fprintf(fid,J);
        fclose(fid);
        
        disp(['Channel ' num2str(ch) ' imported.'])
    end
end
delete(checkpoint_path);
disp('All done.')

if exist(fullfile(save_dir, 'log.txt'))
    delete(fullfile(save_dir, 'log.txt'));
end


end


%% Superblock structure, determine multi-tank vs single-tank data for SST

function [tank,blocks] = sb_structure(tbl)

try
    tank=unique(tbl.tank);
catch
    tank=1;
end

if length(tank)==1
    blocks=unique(tbl.block);
else
    bl_matrix=[];
    for bl=1:length(tank)
        bls=unique(tbl.block(tbl.tank==tank(bl)));
        bls=[bls,ones(length(bls),1)*bl];
        bl_matrix=[bl_matrix;bls];
    end
    blocks=transpose(bl_matrix);
end

end

%% Import multi-unit SSTs

function sst = import_sst(tank,blocks,tank_path,channel)

if length(tank)==1
    if iscell(tank_path)
        tank_path_str=tank_path{tank};
    else
        tank_path_str=tank_path;
    end
    sst = superspiketrain(char(tank_path_str), reshape(blocks,1,numel(blocks)), channel, 0);
else
    sst = superspiketrain_multi(tank_path, blocks, channel, 0);
end


end

%% Assign and save per_unit SSTs

function sst_cell = export_sst(tbl,sst)


K = max(tbl.sortc);
ch = tbl.chan(1);
sst_cell=cell(K+1,1);
for unit = 0:K
    sst_copy = sst;
    sst_copy.Unit = unit;
    if unit>0
        unit_idx = tbl.sortc == unit;
        unit_ts = tbl.ts(unit_idx);
        sst_ts = sst_copy.Spikes.TS;
        
        sst_copy.Spikes(~ismember(sst_ts, unit_ts), :) = [];
        sst_copy.SortCodeType = 'matlab_manual_sort';
    end
    
%     sst_copy = sst2struct(sst_copy); %make it python readable
    
    sst_cell{unit+1}=sst_copy;
end


end

%% Main sorting platform

function sort_code = user_sort(fspace_all,ch,titlestring,explained)

% nSample is important because plotting population PCA data will severely
% slow down GUI processing and user's sorting efficiency. Utilizing the
% brush tool in Matlab, user can select a small sample of clusters, whose
% boundaries in 3D will be used to delineate the population data. nSample
% can be changed by users during sorting.

CO = get(groot,'defaultaxescolororder');
CO=[0.5 0.5 0.5;CO;CO];
nSample=2000;
nTotal = size(fspace_all,1);
if nSample<nTotal
    fspace = fspace_all(randsample(nTotal,nSample),:);
else
    fspace = fspace_all;
end
sort_code = zeros(nTotal,1);

count=1;
sort_idx_rep=zeros(size(fspace,1),1);
auto_indicator=0;
key_count=1;
while count>0
    clf
    if sum(sort_code)>0&auto_indicator==0
        plot3(fspace(~next_sort_idx,1),fspace(~next_sort_idx,2),fspace(~next_sort_idx,3),...
            'o','color',[0.5 0.5 0.5],'markersize',1.2,'markerfacecolor',[0.5 0.5 0.5]);
    elseif sum(sort_code)==0&auto_indicator==0
        if nSample<nTotal
            fspace = fspace_all(randsample(nTotal,nSample),:);
        else
            fspace = fspace_all;
        end
        next_sort_idx=zeros(size(fspace,1),1);
        plot3(fspace(:,1),fspace(:,2),fspace(:,3),...
            'o','color',[0.5 0.5 0.5],'markersize',1.2,'markerfacecolor',[0.5 0.5 0.5]);
    elseif auto_indicator==1
        if nSample<nTotal
            r_ind = randsample(nTotal,nSample);
            fspace = fspace_all(r_ind,:);
            sort_code_rep = sort_code(r_ind);
        else
            fspace = fspace_all;
            sort_code_rep = sort_code;
        end
        
        hold on;
        for clust=0:max(sort_code_rep)
            idx = sort_code_rep==clust;
            if clust==0
                color=1;
            else
                color=clust+1;
                str=sprintf('Unit %d: %d',clust,sum(sort_code==clust));
                disp(str);
            end
            plot3(fspace(idx,1),fspace(idx,2),fspace(idx,3),...
                'o','color',CO(color,:),'markersize',1.2,'markerfacecolor',CO(color,:));
            
        end
    end
    try
        view(current_view);
        xlim(current_lim(1,:));
        ylim(current_lim(2,:));
        zlim(current_lim(3,:));
    end
    if key_count==1
        orig_view = get(gca,'view');
        orig_lim = [get(gca,'xlim');get(gca,'ylim');get(gca,'zlim')];
    end
    title({titlestring,['Channel ' num2str(ch)]},'interpreter','none')
    set(gca,'xtick',0,'xticklabel',sprintf('pc1: %.0f',explained(1)),...
        'ytick',0,'yticklabel',sprintf('pc2: %.0f',explained(2)),...
        'ztick',0,'zticklabel',sprintf('pc3: %.0f',explained(3)))
    h=get(gca,'children');
    grid on
    brush on
    k=0;
    warning('off');
    while ~k
        key_count=key_count+1;
        key_press=waitforbuttonpress;
        if key_press
            key=get(gcf,'currentcharacter');
        else
            key=0;
        end
        current_view = get(gca,'view');
        current_lim = [get(gca,'xlim');get(gca,'ylim');get(gca,'zlim')];
        switch key
            case 'a'
                view(current_view+[15 0]);current_view=get(gca,'view');
            case 'd'
                view(current_view+[-15 0]);current_view=get(gca,'view');
            case 'w'
                view(current_view+[0 -15]);current_view=get(gca,'view');
            case 's'
                view(current_view+[0 15]);current_view=get(gca,'view');
            case 'z'
                current_lim = current_lim.*0.5;
                xlim(current_lim(1,:));ylim(current_lim(2,:));zlim(current_lim(3,:));
            case 'x'
                current_lim = current_lim.*2;
                xlim(current_lim(1,:));ylim(current_lim(2,:));zlim(current_lim(3,:));
            case 'c'
                if auto_indicator~=1
                    try
                        selected_data = h.BrushHandles.Children(1).VertexData;
                        sort_idx_rep = (ismember(fspace(:,1:3),selected_data','rows'));
                        %
                        boundary=zeros(3,2);
                        idx_bound = zeros(size(fspace_all,1),3);
                        for dimension=1:3
                            boundary(dimension,:)=[min(selected_data(dimension,:)) max(selected_data(dimension,:))];
                            idx_bound(:,dimension)=fspace_all(:,dimension)>boundary(dimension,1)&...
                                fspace_all(:,dimension)<boundary(dimension,2);
                        end
                        sort_idx = sum(idx_bound,2)==3;
                    catch
                        sort_idx=sort_code==0;
                        sort_idx_rep = logical(ones(size(fspace(:,1))));
                    end
                    next_sort_idx = next_sort_idx + sort_idx_rep;
                    next_sort_idx(next_sort_idx>1)=1;
                    sort_code(sort_idx&sort_code==0) = count;
                    fprintf('Unit %d selected. (%d)\n',count,sum(sort_code==count))
                    k=1;
                    count=count+1;
                else
                    disp('Please remove current sort first. (press r)')
                end
            case 'm'
                disp('Enter number of clusters: ');
                waitforbuttonpress;
                nclust=get(gcf,'currentcharacter');
                disp(nclust);
                nClust = str2num(nclust);
                sort_code = em_gmm(fspace_all,nClust);
                auto_indicator=1;
                k=1;
                disp('EM-GMM summary: ')
                
            case 'k'
                disp('Enter number of clusters: ');
                waitforbuttonpress;
                nclust=get(gcf,'currentcharacter');
                disp(nclust);
                nClust = str2num(nclust);
                if nClust==0|(isempty(nClust))
                    nClust=1;
                end
                sort_code = sorter_kmeans(fspace_all,nClust);
                auto_indicator=1;
                k=1;
                disp('K-mean summary: ')
            case 'v'
                close all;
                disp('Plotting waveforms and ISI...')
                k=1;
                count=0;
            case '+'
                nSample=nSample*2;
                if nSample>=nTotal
                    nSample = nTotal;
                end
                k=1;
            case '='
                nSample=nSample*2;
                if nSample>=nTotal
                    nSample = nTotal;
                end
                k=1;
            case '-'
                nSample=ceil(nSample./2);
                if nSample>=nTotal
                    nSample = nTotal;
                end
                k=1;
            case 'r'
                current_lim = [prctile(fspace(:,1),10) prctile(fspace(:,1),90);...
                    prctile(fspace(:,2),10) prctile(fspace(:,2),90);...
                    prctile(fspace(:,3),10) prctile(fspace(:,3),90)]*(2.^4);
                xlim(current_lim(1,:));ylim(current_lim(2,:));zlim(current_lim(3,:));
                
                sort_idx_rep = logical(ones(size(fspace(:,1))));
                sort_code = zeros(nTotal,1);
                count=1;
                auto_indicator=0;
                disp('Sorts removed. Re-plotting current channel...')
                k=1;
            case '1'
                xlim(orig_lim(1,:));ylim(orig_lim(2,:));zlim(orig_lim(3,:));
            case '3'
                view(3);
            case '2'
                view(2);
        end
    end
end
close all


end

%%
function display_unit(tbl)
usort=unique(tbl.sortc);
co=get(groot,'defaultaxescolororder');
co=repmat(co,10,1);
ssize=get(0,'screensize');
set(gcf,'position',[ssize(3)-350-410 ssize(4)-520 400 400])

for s=1:2
    subplot(2,1,s)
    for i=1:length(usort)
        hold on
        idx = tbl.sortc==i;
        wf_mean = mean(tbl.waves(idx,:),1);
        wf_std = std(tbl.waves(idx,:),1);
        if s==2
            if sum(diff(wf_mean(2:5)))<0
                [~,im]=min(wf_mean);
            else
                [~,im]=max(wf_mean);
            end
            wf_mean = circshift(wf_mean,10-im);
            wf_std = circshift(wf_std,10-im);
        end
        plot(wf_mean,'color',co(i,:),'linewidth',1)
        plot(wf_mean + wf_std,'color',co(i,:),'linestyle',':')
        plot(wf_mean - wf_std,'color',co(i,:),'linestyle',':')
        if s==1
            title('aligned to thr crossing')
        elseif s==2
            title('aligned to peak amp')
        end
    end
end
end
%%
function L = display_isi(tbl)

usort=unique(tbl.sortc);
usort(usort==0)=[];
L=length(usort);
co=get(groot,'defaultaxescolororder');
co=repmat(co,10,1);

figure;
ssize=get(0,'screensize');

set(gcf,'position',[ssize(3)-350 ssize(4)-100-100*L-20 250 100*L]);
if L>7
    set(gcf,'position',[ssize(3)-350 0 250 900]);
end

for i=1:L
    subplot(L,1,i)
    hold on
    idx = tbl.sortc==i;
    ts_isi = diff(tbl.ts(idx));
    bin = 0:0.0002:0.06;
    isih = hist(ts_isi,bin);
	trim = bin>0.05;
    bin(trim)=[];
    isih(trim)=[];
    bar(bin,isih,'facecolor',co(i,:),'edgecolor',co(i,:));
    xlim([-0.001 0.05])
    set(gca,'fontsize',8)
    box off;
    if i<L
        set(gca,'xtick',[])
    end
end


end

%%
function instruction_display()

text{1}='[a d w s] to move clusters';
text{end+1}='[z x] to zoom';
text{end+1}='[m k] to perform automatic clustering (em_gmm/k-mean)';
text{end+1}='[2 3] to change view angle'; 
text{end+1}='[r] to resort with different samples';
text{end+1}='[- +] to decrease/increase number of samples';
text{end+1}='[c] to confirm unit';
text{end+1}='[v] to move onto the next channel';

disp(text')


end

%%
function index_keep = sb_select(L)

index_keep=zeros(L,1);
for m=1:L
    subplot(L,1,m)
    ax(m,:)=get(gca,'position');
end

b=1;
count=0;
tag=[];


disp('Left click to select unit. Right click to end.');

while b==1
    
    [x,y,b]=ginput(1);
    if b==1
        cp=get(gca,'position');
        [~,index]=min(abs(ax(:,2)-cp(2)));
        if ~isempty(index)
            sbcolor = get(subplot(L,1,index),'color');
            if sum(sbcolor)==3
                set(subplot(L,1,index),'color',[0.7 0.7 0.7])
            else
                set(subplot(L,1,index),'color',[1 1 1])
            end
        end
    end
end

ax=[];
for m=1:L
    h=subplot(L,1,m);
    ax(m,:)=get(h,'color');
end
close all;
index_keep = ax(:,1)==0.7;


end
%%
function J = sstcell2py(sst_sorted)

    sst_sorted_new=struct;
    sst_sorted_new.spikes=[];
    for j=1:length(sst_sorted)
        sst=sst2struct(sst_sorted{j});
        if j==1
           sst_sorted_new.epocs=sst.epocs;
        end
        sst=rmfield(sst,'epocs');
        spikes=sst.spikes;
        spikes=[spikes ones(length(spikes),1)*(j-1)];
        sst_sorted_new.spikes=[sst_sorted_new.spikes;spikes];
    end
    J=jsonencode(sst_sorted_new);
end